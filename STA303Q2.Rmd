```{r pmisc}
if (!requireNamespace("Pmisc", quietly = TRUE)) {
  install.packages("Pmisc", repos = "http://r-forge.r-project.org")
}

library(Pmisc)
```

Importing the Data:
```{r}
heatUrl = "http://pbrown.ca/teaching/appliedstats/data/sableIsland.rds"
dir.create("cache", showWarnings = FALSE)
heatFile = file.path("cache", basename(heatUrl))

if (!file.exists(heatFile)) 
  download.file(heatUrl, heatFile)

x = readRDS(heatFile)
names(x) = gsub("[.]+C[.]", "", names(x))
x$Date = as.Date(x$Date)
x$month = as.numeric(format(x$Date, "%m"))
x$summer = x$month %in% 5:10
```

Code for 3 GAM:
```{r}
x[100, ]
x$dateInt = as.integer(x$Date)
x$yearFac = factor(format(x$Date, "%Y"))

xSub = x[x$summer & !is.na(x$Max.Temp), ]

View(xSub)
View(x)

library("mgcv")

# Model 1 (res1)
res1 = gam(update.formula(
  Max.Temp ~ s(dateInt, pc = as.integer(as.Date("1990/7/1")), k = 100) + 
  s(yearFac, bs = "re"), 
  Pmisc::seasonalFormula(period = 365.25, harmonics = 1:2, var = "dateInt")
), data = xSub, method = "ML", optimizer = "efs")

# Model 2 (res2)
res2 = gam(update.formula(
  Max.Temp ~ s(dateInt, pc = as.integer(as.Date("1990/7/1")), k = 4) + 
  s(yearFac, bs = "re"), 
  Pmisc::seasonalFormula(period = 365.25, harmonics = 1:2, var = "dateInt")
), data = xSub, method = "ML", optimizer = "efs")

# Model 3 (res3)
res3 = gam(update.formula(
  Max.Temp ~ s(dateInt, pc = as.integer(as.Date("1990/7/1")), k = 100), 
  Pmisc::seasonalFormula(period = 365.25, harmonics = 1:2, var = "dateInt")
), data = xSub, method = "ML", optimizer = "efs")

# Output the formula of res1
res1$formula
res2$formula
res3$formula

```

Q1: 1. Write down a set of equations (or several sets of equations) which corresponds to the three calls to gam.
Explain the differences between the models in res1, res2 and res3? (2 points)
##Discussion: 
res 1 and res 3 have a k value equal to 100, this is a component of the smooth term. Due to the k value being greater
in these 2 models, compared to res 2 having a k value of 4 in the smooth term, res1 and res3 will be able to capture more
of the data, allowing more flexibility in the smooth function. For res 2 with a k value of 4 the smooth term will have a more generalized shape, not accounting for detailed variability in the data.

Another key difference is that Res3 does not include yearFac as a random effect, whereas Res1 and Res2 both treat yearFac as a random effect. This means that in Res3, the model assumes that the intercept for Max.Temp is the same for all years. However, this assumption is likely not accurate, as temperatures can vary significantly from year to year, especially over long periods. By including yearFac as a random effect, Res1 and Res2 allow for different intercepts for each year, better capturing year-to-year variations in the data.

1.)

$$
g(\mathbb{E}[Y]) = \beta_0 + f_1(\text{yearFac}) + f_2(\text{dateInt}) + f_3(\text{yearFac} * \text{dateInt}) + \epsilon
$$

##Q2

```{r}

```

##Q3: 
Create a nicer version of fig. 4, with axis labels and an informative caption. You can refer to variables
given in the equations from Question 1. The caption should be two or three sentences, a reader familiar
with generalized additive models should understand everything about the figure (even if they have not
read this homework assignment) (3 points)
```{r}
Syear = unique(xSub$yearFac)

predYear = do.call(cbind, predict(res1, 
                                  newdata = data.frame(yearFac = Syear, dateInt = 0), 
                                  type = "terms", 
                                  terms = "s(yearFac)", 
                                  se.fit = TRUE)) %*% Pmisc::ciMat()

newdat = data.frame(Date = seq(as.Date("1900/1/1"), as.Date("2035/12/31"), by = "2 weeks"), 
                    yearFac = Syear[1])

newdat$dateInt = as.integer(newdat$Date)

predTrend = do.call(cbind, predict(res1, 
                                   newdat, 
                                   type = "terms", 
                                   terms = "s(dateInt)", 
                                   se.fit = TRUE)) %*% Pmisc::ciMat()

newX = predict(res1, newdata = newdat, type = "lpmatrix")

simCoef <- rmvn(10, coef(res1), vcov(res1))

isTrend = grep("s[(]dateInt", colnames(newX))

simTrend = tcrossprod(newX[, isTrend], simCoef[, isTrend])

Syear = as.numeric(as.character(Syear))

View(newdat)

matplot(Syear, predYear, 
        xlab = "Degrees C",
        ylab = "Prediction Interval",
        cex = c(1, 0, 0), 
        pch = 16,
        col = "black")

segments(Syear, predYear[, 2], Syear, predYear[, 3], lwd = 0.5)

matplot(newdat$Date, simTrend, 
        type = "l", 
        lty = 1, 
        col = RColorBrewer::brewer.pal(ncol(simTrend), "Paired"), 
        xaxt = "n", 
        xaxs = "i", 
        yaxs = "i", 
        ylim = range(predTrend),
        xlab = "")

matlines(newdat$Date, predTrend, 
         lty = c(1, 2, 2), 
         col = "black", 
         lwd = 2)

forX = as.Date(ISOdate(seq(1880, 2050, by = 25), 1, 1))

axis(1, forX, format(forX, "%Y"))

```

##Q4
```{r}
xnew = x[x$Date <= as.Date("1995-12-31") & !is.na(x$Max.Temp), ]
View(xnew)

##Fitting the new model
res_new = gam(update.formula(
  Max.Temp ~ s(dateInt, pc = as.integer(as.Date("1930/7/1")), k = 100) + 
  s(yearFac, bs = "re"), 
  Pmisc::seasonalFormula(period = 365.25, harmonics = 1:2, var = "dateInt")
), data = xnew, method = "ML", optimizer = "efs")
```

Predictions:
```{r}
Syear = unique(xSub$yearFac)

predYear = do.call(cbind, predict(res_new, newdata = data.frame(yearFac = Syear,
                dateInt = 0), type = "terms", terms = "s(yearFac)", se.fit = TRUE)) %*%
                Pmisc::ciMat()

# Create future data (1996-2025) for prediction
newdat = data.frame(Date = seq(as.Date("1996/1/1"), as.Date("2025/12/31"), by = "2 weeks"),
                    yearFac = Syear[1])
newdat$dateInt = as.integer(newdat$Date)

predTrend = do.call(cbind, predict(res_new, newdat, type = "terms", terms = "s(dateInt)",
                   se.fit = TRUE)) %*% Pmisc::ciMat()

# Simulate model uncertainty
newX = predict(res_new, newdata = newdat, type = "lpmatrix")
simCoef = rmvn(10, coef(res_new), vcov(res_new))
isTrend = grep("s[(]dateInt", colnames(newX))
simTrend = tcrossprod(newX[, isTrend], simCoef[, isTrend])

```
